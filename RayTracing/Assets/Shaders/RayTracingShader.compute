// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define MAX_DEPTH 1
#define NUM_SAMPLES 1
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float2 _PixelOffset;

// light data
float3 _PointLightPos;
float4 _PointLightProperties;

static const float PI = 3.14159265f;
static const float EPSILON = 1e-6;

//-----------------------------------
// Utilty
float sdot(float3 x, float3 y, float f = 1.0f)
{
    return saturate(dot(x, y) * f);
}

float energy(float3 color)
{
    return dot(color, 1.0f / 3.0f);
}

float2 mod2(float2 x, float2 y)
{
    return x - y * floor(x / y);
}

//-----------------------------------
// Random
float2 _pixel;
float _seed;
float rand()
{
    float result = frac(sin(_seed / 100.0f * dot(_pixel, float2(12.9898f, 78.233f))) * 43758.5453f);
    _seed += 1.0f;
    return result;
}

//-----------------------------------
// Ray
struct Ray
{
    float3 origin;
    float3 direction;
    float3 energy;
};

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    ray.energy = float3(1.0f, 1.0f, 1.0f);
    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    // Transform from screen space to world space
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    //Inverse the perspective projection
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    
    // Transform the direction from camera space to world space
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);
    
    return CreateRay(origin, direction);
}

//-----------------------------------
// RayHit // like triangleHitInfo
struct RayHit
{
    float3 position;
    float distance;
    float3 normal;
    float3 albedo;
    float3 specular;
    float smoothness;
    float3 emission;
};

RayHit Raycast()
{
    RayHit hit;
    hit.position = float3(0.0f, 0.0f, 0.0f);
    hit.distance = 1.#INF;
    hit.normal = float3(0.0f, 0.0f, 0.0f);
    hit.albedo = float3(0.0f, 0.0f, 0.0f);
    hit.specular = float3(0.0f, 0.0f, 0.0f);
    hit.smoothness = 0.0f;
    hit.emission = float3(0.0f, 0.0f, 0.0f);
    return hit;
}

//-----------------------------------
// Structure
struct RayTracingMaterial
{
    float3 albedo;
    float3 specular;
    float smoothness;
    float3 emission;
};

struct MeshInfo
{
    int nodeOffset;
    int triangleOffset;
    float4x4 Matrix4x4localToWorldMatrix;
    float4x4 Matrix4x4worldToLocalMatrix;
    RayTracingMaterial material;
};

struct TriangleHitInfo
{
    bool isHit;
    float distance;
    float3 hitPosition;
    float3 hitNormal;
    int triIndex;
};

struct BVHNode
{
    float3 boundsMin;
    float3 boundsMax;
    int startIndex;
    int triangleCount;
};

struct Triangle
{
    float3 posA, posB, posC;
    float3 normA, normB, normC;
};

struct ModelHitInfo
{
    bool isHit;
    float3 normal;
    float3 hitPoint;
    float distance;
    RayTracingMaterial material;
};

// create Buffers
StructuredBuffer<BVHNode> _BvhNodesBuffer;
StructuredBuffer<Triangle> _BvhTriangleBuffer;
StructuredBuffer<MeshInfo> _MeshInfoBuffer;

//-----------------------------------
// Intersection
// calculate the intersection of a ray with a triangle using the Moller-Trumbore algorithm
TriangleHitInfo IntersectTriangle(Ray ray, Triangle tri, inout float t, inout float u, inout float v)
{
    // find vectors for two edges sharing vert0
    float3 edge1 = tri.posB - tri.posA;
    float3 edge2 = tri.posC - tri.posA;
    
    // begin calculating determinant - also used to calculate U parameter
    float3 pvec = cross(ray.direction, edge2);
    
    // if determinant is near zero, ray lies in plane of triangle
    float det = dot(edge1, pvec);
    //if (abs(det) < EPSILON)
    //    return false;
    float invDet = 1.0f / det;
    
    // calculate distance from vert0 to ray origin
    float3 tvec = ray.origin - tri.posA;
    
    // calculate U parameter and test bounds
    u = dot(tvec, pvec) * invDet;
    //if (u < 0.0f || u > 1.0f)
    //    return false;
    
    // prepare to test V parameter
    float3 qvec = cross(tvec, edge1);
    
    // calculate V parameter and test bounds
    v = dot(ray.direction, qvec) * invDet;
    //if (v < 0.0f || u + v > 1.0f)
    //    return false;
    
    // calculate W
    float w = 1 - u - v;
    
    // calculate distance, ray intersects triangle
    t = dot(edge2, qvec) * invDet;
    //return t > EPSILON;
    
    TriangleHitInfo hitInfo;
    hitInfo.isHit = det >= EPSILON && t >= 0 && u >= 0 && v >= 0 && w >= 0;
    hitInfo.distance = t;
    hitInfo.hitPosition = ray.origin + t * ray.direction;
    //hitInfo.hitNormal = normalize(w * tri.normA + u * tri.normB + v * tri.normC);
    hitInfo.hitNormal = normalize(cross(edge1, edge2));
    
    return hitInfo;
}

float RayBoundingBoxDistance(Ray ray, float3 boxMin, float3 boxMax)
{
    // get ray inverse direction
    float3 rayInvDir = 1.0f / ray.direction;    
    
    float3 distanceMin = (boxMin - ray.origin) * rayInvDir;
    float3 distanceMax = (boxMax - ray.origin) * rayInvDir;
    float3 distance1 = min(distanceMin, distanceMax);
    float3 distance2 = max(distanceMin, distanceMax);
    float distaceNear = max(max(distance1.x, distance1.y), distance1.z);
    float distaceFar = min(min(distance2.x, distance2.y), distance2.z);
    
    bool hit = distaceFar >= distaceNear && distaceFar >= 0;
    float distance = hit ? distaceNear > 0 ? distaceNear : 0 : 1.#INF;
    return distance;
}

TriangleHitInfo RayTriangleBVH(Ray ray, float rayLength, int nodeOffset, int triOffset, inout int2 stats)
{
    TriangleHitInfo result;
    result.distance = rayLength;
    result.triIndex = -1;
    
    // BVH max depth is set to 32
    int stack[32];
    int stackIndex = 0;
    stack[stackIndex++] = nodeOffset + 0;
    
    while (stackIndex > 0)
    {
        BVHNode node = _BvhNodesBuffer[stack[--stackIndex]];
        bool isLeaf = node.triangleCount > 0;
        
        if (isLeaf)
        {
            for (int i = 0; i < node.triangleCount; i++)
            {
                Triangle tri = _BvhTriangleBuffer[triOffset + node.startIndex + i];
                float t, u, v;
                TriangleHitInfo triHitInfo = IntersectTriangle(ray, tri, t, u, v);
                stats[0]++; // count triangle intersection tests
                
                if (triHitInfo.isHit && triHitInfo.distance < result.distance)
                {
                    result = triHitInfo;
                    result.triIndex = node.startIndex + i;
                }
            }
        }
        else
        {
            int childIndexA = nodeOffset + node.startIndex + 0;
            int childIndexB = nodeOffset + node.startIndex + 1;
            BVHNode childA = _BvhNodesBuffer[childIndexA];
            BVHNode childB = _BvhNodesBuffer[childIndexB];
            
            float distanceA  = RayBoundingBoxDistance(ray, childA.boundsMin, childA.boundsMax);
            float distanceB  = RayBoundingBoxDistance(ray, childB.boundsMin, childB.boundsMax);
            stats[1]++;
            
            bool isNearestA = distanceA <= distanceB;
            float distanceNear = isNearestA ? distanceA : distanceB;
            float distanceFar = isNearestA ? distanceB : distanceA;
            int childIndexNear = isNearestA ? childIndexA : childIndexB;
            int childIndexFar = isNearestA ? childIndexB : childIndexA;
            
            if (distanceFar < result.distance)
            {
                stack[stackIndex++] = childIndexFar;
            }
            if (distanceNear < result.distance)
            {
                stack[stackIndex++] = childIndexNear;
            }
        }
    }
    return result;
}

ModelHitInfo CalculateRayCollision(Ray worldRay, out int2 stats)
{
    ModelHitInfo result;
    result.distance = 1.#INF;
    Ray localRay;
    
    MeshInfo mesh = _MeshInfoBuffer[0];
    
    localRay.origin = mul(mesh.Matrix4x4localToWorldMatrix, float4(worldRay.origin, 1));
    localRay.direction = mul(mesh.Matrix4x4localToWorldMatrix, float4(worldRay.direction, 0));
    
    float3 localRayInvDir = 1.0f / localRay.direction;
    
    TriangleHitInfo hit = RayTriangleBVH(localRay, result.distance, mesh.nodeOffset, mesh.triangleOffset, stats);
    
    if (hit.distance < result.distance)
    {
        result.isHit = true;
        result.distance = hit.distance;
        result.hitPoint = mul(mesh.Matrix4x4localToWorldMatrix, float4(hit.hitNormal, 0)).xyz;
        result.normal = worldRay.origin + worldRay.direction * hit.distance;
        result.material = mesh.material;
    
    }
    
    return result;
}

//-----------------------------------
// Sampling
float3x3 GetTangentSpace(float3 normal)
{
    // Choose a helper vector for the cross product
    float3 helper = float3(1, 0, 0);
    if (abs(normal.x) > 0.99f)
        helper = float3(0, 0, 1);

    // Generate vectors
    float3 tangent = normalize(cross(normal, helper));
    float3 binormal = normalize(cross(normal, tangent));
    return float3x3(tangent, binormal, normal);
}

float3 SampleHemisphere(float3 normal, float alpha)
{
    // Sample the hemisphere, where alpha determines the kind of the sampling
    float cosTheta = pow(rand(), 1.0f / (alpha + 1.0f));
    float sinTheta = sqrt(1.0f - cosTheta * cosTheta);
    float phi = 2 * PI * rand();
    float3 tangentSpaceDir = float3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);

    // Transform direction to world space
    return mul(tangentSpaceDir, GetTangentSpace(normal));
}

//-----------------------------------
// Trace

float3 Trace(Ray ray)
{
    
    int2 stats = int2(0, 0); // Initialize stats if needed
    ModelHitInfo hitInfo = CalculateRayCollision(ray, stats);
    
    if (hitInfo.isHit)
    {
        // Return the normal of the hit triangle
        return hitInfo.normal;
    }
    else
    {
        // If no hit, return a default color (e.g., sky color)
        return float3(0.0f, 0.0f, 0.0f); // Light blue color
    }
}

//-----------------------------------
// Shade
float SmoothnessToPhongAlpha(float s)
{
    return pow(1000.0f, s * s);
}

//-----------------------------------
// kernel
[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    _pixel = float2(id.xy);
    // Get the dimensions of the render texture
    uint width, height;
    Result.GetDimensions(width, height);
    
    // Transform pixel to UV coordinates
    float2 uv = float2((id.xy + _PixelOffset) / float2(width, height) * 2.0f - 1.0f);
    
    // Create a ray from the camera for the UVs
    Ray ray = CreateCameraRay(uv);
    
    // Trace and shade
    float3 result = float3(0.0f, 0.0f, 0.0f);
    for (int i = 0; i < NUM_SAMPLES; i++)
    {

        result += Trace(ray);
    }
    
    Result[id.xy] = float4(result, 1.0f);
}
